BUFFERS
Client-Server
[x] Server Info
[x] cacheMemory info
[x] UdpMessage Buffer write,read,open
    []Type
udpMessageOpen:
    [x]fname
    [x]flags
    [x]fd (filedescriptor)
    [x]attributes
udpMessageWrite:
    [x]size to write
    [x]msg
    [-]fd (fileID)
    [x]fdInfo(fileInformation)
    [x]attributes
udpMessageWrite:
    [x]size to read
    [x]msg
    [-]fd (fileID)
    [x]fdInfo(fileInformation)
    [x]attributes
fileID
    [x]int fd
    [x]int session
fileDescritporInfo
    [x]int posStart
    [x]int writePermmission
    [x]int readPermission


CLIENT STRUCTURES
middlewarefds
    [x] Integer appID--->filedescriptor
filesInClient
    [x] Integer serverId --->fileInformation
STRUCTURES IF NO ID MESSAGE CAME
noIDreadMessages
    [x] Integer appID --->LIST of Messages read
    [] remove this structure when closing this file descriptor
    []messages are removing when we receive ashwer from server for them
noIDwriteMessages
    [x] Integer appID --->List of messages write
SERVER STRUCTURES
filesInServer
    [x]ids--->file Descriptors (Up to 5)
    [x] ansewr something

for incoming msgs from server(read,write,open)
[x] readMsgs
  [x] Delete them when application takes them

for requests
[x] requests
  [x] Deletes them when we receive answer

for duplication
[] idsMiddleware(read,write,open)
  [] Deletes them SOMEHOW **********

API

1)[x] Init
    [x] ServerInfo(ipAddr,port)
    [x] cacheMemoryInfo()
2)[x] open --> Open a file and return a file descriptor
    [x] No file EXIST in client
        [x] Prepare the request
            [x]uppMEssageOPen
        [x]send the request
        [x]block until client take the ansewr
    [x]if file exists
        [x]O_EXCL
            [x]return error
        [x]O_TRUNC && O_RDONLY
            [x]return error
        [x]O_TRUNC
            send new request to server
        [x]else give new id to fd and prepares the info
    [x] Sending packets until specific  id has been added to the idsMiddleware
    [x] Store info for this file descriptor
    [x] Pass flag arguments to the server
        [x] O_CREAT --> create the file if its not exist
        [x] O_EXCL --> together with o_crate return error if file exists
        [x] O_TRUNC -->  if file exists and is a regular file and the acess mode allows writing will be truncated to length 0
        [x] O_RDONLY
        [x] O_RDWR
        [x] O_WRONLY
     [x] if appplication unblock and his request is not proecessed -->> lock again
     [x] if simple open , read and write flags;

     TESTS
     [] open for all scenarios of flags
     [] open->read->open the same file (for write too)
     [] open->write->open the same file (for read too)

3)[] read
     [x] fragmented teh packet if the requested size is bigger than the udp size

     [x] send specific starting byte and receive next starting byte after read for this specific file descriptor
     [x] if appplication unblock and his request is not proecessed -->> lock again
     [x] must return the readMsg to application somehow;
     [x] check if wanted read starting byte is too long
     [x] if server hasnt this fileID send back to client an answer with the obligation to client to send a new open request for a new ID
     [x] this newID is used for new communication with server

     TESTS
     [] 2 or more apps read from the same big file
     [] one applications reads andd then open a new fd and read again.
4)[] write
    [x] fragmented files are sended one by one with max payload (adjust payload with header sended each time)
    [x] packet
        header
        [x] writeInt : ack for client receive
        [x]  type : write
        [x]  fileDescriptor:
               [x] fileID: communicates with client-server(id + session)
               [x] writePermission
               [x] readPermission
               [x] clientId: communicates with app-client
        [x]Payload:
            String msg
    [x]

5)[x] seek
       [x] SEEK_SET The offset is set to offset bytes.
       [x] SEEK_CURR  The offset is set to its current location plus offset bytes.
       [x] SEEK_END  The offset is set to the size of the file plus offset bytes.

6)[] close
      [x] Remove fd info from client
      [] Remove from application this fd

Request-reply Protocol
1) [] Choose request-reply protocol
    [x] Duplicates client side
        [x] idsMiddleware Buffer
    [] Remove ids from Buffers
    [x] Resend until receive

Functionalities
1)[χ] Εντοπισμός/δημιουργεία ενος αρχείου και λήψη του εσωτερικού αναγνωριστικού
       [x] send information to server(fname,flags)
       [x] server receive the request and prepares an integer id for the fname;
            [χ] based on the session and the new id
                [χ]session is the number specific for this run of the seerver if error occurs, new session number after reboot
            [x] gives an id to each filedescripto
            [x] return an error -1 if (O_CREAT | O_EXCL)
                [x] or wrong flags
            [x] return error if requested flag is note permitted based on the file permissions
       [x] client-middleware receives the packet and
            [x] stores the id value of the request
               [x] check for duplicates
            [x] create fileDescriptor for this value and returns openInt to app(specific for each app because is given from the client middleware)
                [x] stores file descriptor to buffer(all information we want for readding, writing etc)


2)[] διάβασμα δεδομένων απο αρχείο με βάση το αναγνωριστικό  του
       [x] give an id for the request readInt
       [x] create an udpMessageRead store it to request
       [x] block until client process it
       [x] client sends the packet until receive answer (at least once)
       [x] when answer received
            [x] client stores the id to midlewares id for duplicates
            [x] client stores the new file descriptor(new starting point) into file descriptors buffer
            [x] put the answer into readMsgs for App
       []
        .....

3)[] Γράψιμο δεδομένων σε αρχείο με βάση το αναγνωριστικό του
      [x] check if this file descriptor exists
      [x] check if this file descriptor has write permission
      [x] writeInt++
      [x] creat udpMessageWrite and add it to requests
      [x] block
      [x] when client-middleware wants sends this message too server
      [χ] client is receivinve the server answer for new fd infos and add them
      [] overwrite data if there is .


Server
Open:
    [x] check if the requested fileName is already opened
        [x] if it is not  we check if we can opene it ..with maximum file descriptors size
            [x] if we cant we return
            [x] if we can
                [x] we craete a new fileid(ID and sessio)
                [x] we create a new file channel
                [x] we create the udpAnsewr("Open",openMsg.getFlags(),openMsg.getOpenACK(),openMsg.getFiled().getClientID(),attributes,openMsg.getFiled()))
        [x] if it is we return this fileChannel
    [x] we return the id based on the flags(O_EXCL : if exist  return error)
Read:
    []checkk if this fileId exists
        [] if its not sends an udpNoIdRead(type,xtpye,fileDescriptor)
        [] so this client will ask for open request
    []else we take the file descriptor, position him at wnated pos
    []read
    []sends read butes
Write:
     []checkk if this fileId exists
            [] if its not sends an udpNoIdWritte(type,xtpye,fileDescriptor)
            [] so this client will ask for open request
        []else we take the file descriptor, position him at wanted pos
        []
]Max_CAPACITY:
    []
NO_ID_READ:
    []
NO_ID_WRITE:
    []


SECOND PART---> CACHE
Structure

Cache {
    LinkedList<Blocks>
    size = sizeOfcache ?
    freshT = Χρόνος φρεσκάδασ σε seconds
}

Blocks {
    byte [] = new byte[sizeOfBlock]

    size = sizeOf block ?
}


Insert cache

[] if an empty block exist put it there these bytes until no empty blocks exists.
[] if non-empty blocks exists .Then we do teh following
    [] if these bytes are already exist ..we replace them and we refresh the timestamps
    [] if these bytes does not exist ..we delete the oldest blocks and put them there


READ CACHE
[] We return at a block the bytes that we take from the cache
[] if these bytes are valid and if the modification timestamp is valid
    []if not we send a remote or more read requests to server
    [] and we insert the bytes that we read at cache
[] else we take the bytes that we can from the cache and the rest from the server


WRITE CACHE
[] if the application wants to write something at a specific file descriptor then we send it directly to server and if WE WRITE ALL TEH BYTES THAT we want then the client
insert it to the cache
    [] if already exists , we replace it
    [] if does not exist then we put it at an empty block or put it.
